# 设计模式

申明： 本文所描述的设计模式都会使用C++语言来实现，是在CentOS7.5以上的编译环境运行，使用CMAKE工具进行管理项目，所有代码均可以运行通过。

参考连接：http://c.biancheng.net/view/1361.html

### 1 UML类图简单介绍

#### 1.1 类、接口和类图

##### 1.1.1 类

类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。

 (1) 类名（Name）是一个字符串，例如，Student。

 (2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：

```
[可见性]属性名:类型[=默认值]
```

例如：-name:String

注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。

 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：

```
[可见性]名称(参数列表)[:返回类型]
```

例如：+display():void。

 如下所示是学生类的 UML 表示。

![image-20211202105222973](E:\private\MyProject\DesignModern\Picture\ClassDefine_UML.png)

``` 
类图用 3 个矩形拼接表示，最上面的部分标识类的名称，中间的部分标识类的属性，最下面的部分标识类的方法。
```

类图中，需注意以下几点：

- 抽象类或抽象方法用斜体表示
- 如果是接口，则在类名上方加 <<Interface>>
- 字段和方法返回值的数据类型非必需
- 静态类或静态方法加下划线

##### 1.1.2 接口

接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。

 如下所示是图形类接口的 UML 表示。

![image-20211202105650642](E:\private\MyProject\DesignModern\Picture\InterfaceDefine_UML.png)

##### 1.1.3 类图

类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。

 类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。

#### 1.2 类之间的关系

UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。

##### 1.2.1 依赖关系

依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。如下是人与手机的关系图，人通过手机的语音传送方法打电话。

![image-20211202110207780](E:\private\MyProject\DesignModern\Picture\DependRelation.png)

##### 1.2.2 关联关系

关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。

 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。

 在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。如下是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。

![image-20211202110551457](E:\private\MyProject\DesignModern\Picture\AssociationRelation.png)

##### 1.2.3 聚合关系

聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。

 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。如下是大学和教师的关系图。

![image-20211202110950300](E:\private\MyProject\DesignModern\Picture\AggregationRelation.png)

##### 1.2.4 组合关系

组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。

 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。如下是头和嘴的关系图。

![image-20211202111412061](E:\private\MyProject\DesignModern\Picture\CompositionRelation.png)

##### 1.2.5 继承

泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。

 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示。

![image-20211202112058926](E:\private\MyProject\DesignModern\Picture\InheritanceRelation.png)

##### 1.2.6 实现

实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。

 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示。

![image-20211202112547977](E:\private\MyProject\DesignModern\Picture\RealizationRelation.png)

### 2 6大设计原则（SOLID）

#### 2.1 单一职责



#### 2.2 开闭原则

#### 2.3 里氏替换原则

#### 2.4 依赖倒置原则

#### 2.5 接口编程原则

#### 2.6 迪米特原则

### 3 设计模式分类

#### 3.1 设计模式分类

​			按照设计模式功能，可以将设计模式分为三大类，创建型模式、结构型模式、行为型模式。

##### 3.1.1 创建型模式

​		提供了一种在创建对象的同时隐藏了创建逻辑的方式，使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

常用： 工厂模式、抽象工厂模式、单例模式、建造者模式

不常用：原型模式

##### 3.1.2 结构型模式

​		关注类和对象的结合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。

常用： 适配器模式、桥接模式、装饰器模式、代理模式

不常用： 组合模式、外观模式、享元模式

##### 3.1.3 行为型模式

​		特别关注对象之间的通信。

常用： 责任链模式、迭代器模式、观察者模式、状态模式、策略模式、模板模式

不常用：备忘录模式、命令模式

几乎不用： 访问者模式、中介模式、解释器模式

### 4 具体设计模式

#### 4.1 创建型模式

##### 4.1.1 单例模式

​		单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

单例模式有 3 个特点：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点。

​		单例模式有懒汉和饿汉2种类型，两者之间的区别就是创建实例的时机。

​		懒汉正如名字形容的一样，比较懒，只有在使用的时候才创建实例，是在运行期间创建实例的；饿汉模式比较怕饿，所以就在定义的时候就创建实例，及编译期就创建实例。

##### 4.1.2 工厂模式

##### 4.1.3 抽象工厂模式

##### 4.1.4 原型模式

​		原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。

##### 4.1.5 建造者模式

​		使用多个简单的对象一步一步构建成一个复杂的对象，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

该模式的主要优点如下：

​		1.封装性好，构建和表示分离。

​		2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。

​		3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

其缺点如下：

​		1.产品的组成部分必须相同，这限制了其使用范围。

​		2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。

核心元素：

Builder:抽象建造者

ConcreteBuilder:具体建造者

Director:指挥者

Productor:产品角色

#### 4.2 结构性设计模式

##### 4.2.1 代理设计模式

​		在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

 代理模式的主要优点有：

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性


 其主要缺点是：

- 代理模式会造成系统设计中类的数量增加
- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度；

模式的结构

代理模式的主要角色如下。

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

![image-20211202143343603](E:\private\MyProject\DesignModern\Picture\ProxyMode.png)

##### 4.2.2 桥接设计模式

##### 4.2.3 适配器设计模式

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

 该模式的主要优点如下。

- 客户端通过适配器可以透明地调用目标接口。
- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
- 在很多业务场景中符合开闭原则。


 其缺点是：

- 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
- 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

模式的结构

适配器模式（Adapter）包含以下主要角色。

1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

##### 4.2.4 装饰模式

##### 4.2.5 外观模式

##### 4.2.6 享元模式

##### 4.2.7 组合模式



